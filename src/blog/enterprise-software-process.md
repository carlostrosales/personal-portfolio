# From Many Opinions to One Product: The Real Process Behind Greenfield Enterprise Software

## How I Learned What Building Software Actually Means

When I entered into my first job as a software engineer, I thought it was simply about writing code. I realized that this was far from the truth after a few months. Before even a single line of code is ever written for a particular feature, at least 10+ conversations have been had for it.

Product managers who debated the scope of the feature and how it might be "scope creep" implying that it is beyond the realms of the overall feature or project, designers who may have done UX user research and suggest that it is an essential feature for end users to intuitively do their job, engineers who then question the technical overhead that is needed to complete the feature and how it can be done but will take more time, and then business stakeholders who will demand the feature at X date because it is needed and tied directly to generating revenue or cutting costs.

And this is just one feature, let's not even go into the entire product. I still sit here today wondering how anything ever truly gets built with so much input into one, what may seem to be, simple feature. Yet, a few months later, that feature is successfully designed, developed, tested, and shipped.

## The Becoming of an Engineer

Looking back in retrospect, I mean it somewhat makes sense that this would be how software is brought into the world, especially at the enterprise level working on greenfield applications. But as a newly minted software engineer it seems a bit overwhelming from someone fresh out of college that just finished their senior capstone. Did I mention the capstone was a simple web app built with 2 other classmates? No, I didn't, but yeah this was the capstone that was suppose to prepare me for the "real-world". Thanks CRUD web app. I quickly learned that writing code, testing the code, and then shipping the code was one very small piece of the puzzle. The rest of the puzzle included:

- Product Managers who set priorities and made sure features aligned with the business roadmap.
- Designers who translate business workflows into intuitive, user-friendly workflows
- Engineers from other teams, who's systems our work depends on.
- Business stakeholders who track budgets, resource allocation, revenue targets/cost savings, etc.

Each of these groups have a vested interest in the overall product, just in a different way. Each speaking a different language, with different insight, that operate on different timelines and constraints. For a newcomer it's overwhelming.

## Why Simple Features Aren't Simple

Engineers love to say that they are the sole, core reason features get shipped, they are the true builders. I non-biasely agree. Let's have a thought experiment real quick, let's say I ask come to you, who's an engineer, and ask you to "build it". Well I assume the first thing you are going to say is, "build what?".

Well that's where the other puzzle pieces come in.

As a junior engineer, I thought I would just come in and "build it". Whatever that meant to me at the time. In my mind, building software is a simple process of planning, designing, building, testing, and deploying. What I soon came to realize is that that simple process can be very messy and complex at each stage.

I've personally witnessed a feature go through an initial approval to only receive more feedback that pulls it into many different directions. A design decision that improves app usability, but increases technical complexity. Business decisions shift, and ultimately feature priorties also change pushing one feature to be halted and another to be brought to the forefront.

This seemed to be grueling at times. It feels like a constant challenge on a weekly basis. One solved problem reveals another dependency, another awaiting approval, risk, or discussion. I simply wanted speed and constant delivery, but the product seemed to want thoroughness. I guess this is what true product refinement meant, and the true world of software engineering.

## The Actual Value of Different Perspectives

Over time and what I am discovering even now, is what seemed to be an obstacle and a flaw in the process of the creation of software was actually necessary. Every insight, opinion, and feedback from each of these groups mattered and helped shape the product.

- Product managers ensuring "what" is being built is within scope
- Designers ensuring usability so the product is actually works for real people
- Engineers who question technical trade-offs to ensure the solution is maintainable and scalable
- Business stakeholder tie it back together in terms of real business value rather that is revenue generation, cost savings, or market needs.

Iron sharpens iron as each group sharpened each other.

As a junior engineer, this changed the way I viewed my role and the way I viewed software. My job was not to just code, or even just to build software. It was to listen, understand, and communicate with each of these groups to align in creation of something that would provide value in the real world.

## How To Navigate as a New Engineer

Here is what I wish I would of known when first building software at this scale:

1. Gain context before building

From a high-level, understand what you are building and what actual value it intends to deliver to the business. Does it save x amount of time in a manual process, y amount of annual revenue will be generated, or z annual cost savings will be realized. Understand the business impact, and also what people, teams, organizations have a vested interest in the product. Who are the key stakeholders, what teams are working on the solution to this problem, what is the roadmap, timelines, and key deliverable dates? Gain a general understanding of all of this to understand the scope of the entire project. This will help in building flexible, scalable solutions.

2. Learn the lingo and translate between perspectives

As an engineer, learn to speak to product, design, business, and other engineers. How you speak to engineers may not translate well to business or even design. Speak your reality as a technical engineer in a way that aligns with them.

3. Learn the why behind requests

You will hear many different requests. Instead of getting the request, and then fulfilling the request with your first "how" solution. Grok the request, and learn the why. This will unfold many possibly simpler solutions.

4. Know the system

Understand how different components interact, internally and externally. The dependencies it relies on, and the team's that own them.

5. Ask questions, ask questions, ask questions

Can you just ask questions? They help.

## Final Thoughts

Building software is a journey of collaboration with multiple perspectivea on a shared, larger vision. Where we may know "what" we want to build, but the "how" is a living context that continues to evolve and be shaped from different insights.
